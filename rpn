#!/usr/bin/perl -T -w
#
# Simple RPN calculator. Accepts the four standard operators (+ - * /),
# some fancier operators (**, &, |, ^),
# and some trig functions (natural log, inverse natural log, sine, cosine, and
# tangent)
# Supports a few common constants (e, pi, and tau)
# Since pi is half right, supports 2pi as well

my @stack=("Stack underflow");
my ($arg1, $arg2);
my $eq=0; # the eval below is hard without this.
my $numbers=qr{((|-)(\d*(\.)\d+|\d+(|\.)\d*))};
my $operators=qr{(-|\+|\*|\/|\*\*|\^|\||\&)};
my $functions=qr{(exp|cos|int|log|sin|tan)};
# I would rather build the constants RE from the hash
my $constants=qr{(e|pi|π|2pi|2π|tau|τ)};
my %constants=(
	"e"   => 2.718281828459045,
	"pi"  => 3.141592653589793,
	"π"   => 3.141592653589793,
	"2pi" => 6.283185307179586,
	"2π"  => 6.283185307179586,
	"tau" => 6.283185307179586,
	"τ"   => 6.283185307179586,
);

$VERBOSE=0;

for (@ARGV) {
	if (m/^$numbers$/) {
		push @stack, $1;
	}
	elsif (m/^$operators$/) {
		die "$stack[0]\n" if ($#stack<2); # binary
		$arg2=pop @stack;
		$arg1=pop @stack;
		eval "\$eq = $arg1 $1 $arg2";
		print "$arg1 $1 $arg2 = $eq\n" if $VERBOSE;
		push @stack, $eq;
	}
	elsif (m/^$functions$/) {
		die "$stack[0]\n" if ($#stack<1); # unary
		$arg1=pop @stack;
		eval "\$eq = $1 $arg1";
		print "$1($arg1) = $eq\n" if $VERBOSE;
		push @stack, $eq;
	}
	elsif (m/^$constants$/) {
		push @stack, $constants{$1};
	}	
	else {
		die "$_? Really?\n";
	}
}

print "$stack[-1]\n";
