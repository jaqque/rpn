#!/usr/bin/perl -T -w
#
# Since I was asked,
# (C) 2014 John H. Robinson, IV <jaqque@gmail.com>
#
# Simple RPN calculator. Accepts the four standard operators (+ - * /),
# some fancier operators (**, &, |, ^),
# and some trig functions (natural log, inverse natural log, sine, cosine, and
# tangent)
# Supports a few common constants (e, pi, and tau)
# Since pi is half right, supports 2pi as well

use Scalar::Util qw(looks_like_number);

my @stack=("Stack underflow");
my ($arg1, $arg2);
my $eq=0; # the eval below is hard without this.
my $operators=qr{(-|\+|\*|\/|\*\*|\^|\||\&)};
my $functions=qr{(abs|cos|exp|int|log|rand|sin|sqrt)};
my %extra_functions=(
	# http://en.wikipedia.org/wiki/Inverse_trigonometric_functions#Relationships_among_the_inverse_trigonometric_functions
	# from the half-angle formula
	"acos" => '2 * atan2( sqrt( 1 - $arg1 ** 2 ) / ( 1 + $arg1 ), 1 )',
	"asin" => '2 * atan2( $arg1 / ( 1 + sqrt( 1 - $arg1 ** 2 ) ) , 1 )',
	"atan" => 'atan2( $arg1, 1 )',
	"cot"  => 'cos($arg1) / sin($arg1)',
	"csc"  => '1 / sin($arg1)',
	"sec"  => '1 / cos($arg1)',
	"tan"  => 'sin($arg1) / cos($arg1)',
);
my %constants=(
	"e"   => 2.718281828459045,
	"pi"  => 3.141592653589793,
	"π"   => 3.141592653589793,
	"2pi" => 6.283185307179586,
	"2π"  => 6.283185307179586,
	"tau" => 6.283185307179586,
	"τ"   => 6.283185307179586,
);

$VERBOSE=0;

if ($ARGV[0] eq '-v') {
	$VERBOSE=1;
	shift @ARGV;
}

for (@ARGV) {
	if (looks_like_number ($_)) {
		m/(.*)/; # We can trust looks_like_number(). I hope.
		push @stack, eval $1;
	}
	elsif ($_ ~~ %constants) {
		print "$_ is $constants{$_}\n" if $VERBOSE;
		push @stack, $constants{$_};
	}
	elsif (m/^$operators$/) {
		die "$stack[0]\n" if ($#stack<2); # binary
		$arg2=pop @stack;
		$arg1=pop @stack;
		eval "\$eq = $arg1 $1 $arg2";
		print "$arg1 $1 $arg2 = $eq\n" if $VERBOSE;
		push @stack, $eq;
	}
	elsif (m/^swap$/) {
		die "$stack[0]\n" if ($#stack<2); # binary
		$arg2=pop @stack;
		$arg1=pop @stack;
		print "swapping $arg1 and $arg2\n" if $VERBOSE;
		push @stack, ($arg2, $arg1);
	}
	elsif (m/^$functions$/) {
		die "$stack[0]\n" if ($#stack<1); # unary
		$arg1=pop @stack;
		eval "\$eq = $1 $arg1";
		print "$1($arg1) = $eq\n" if $VERBOSE;
		push @stack, $eq;
	}
	elsif ($_ ~~ %extra_functions) {
		die "$stack[0]\n" if ($#stack<1); # unary
		m/(.*)/; # We can trust it - it's a hash key
		$arg1=pop @stack;
		eval "\$eq = $extra_functions{$1}";
		print "$1($arg1) = $eq\n" if $VERBOSE;
		push @stack, $eq;
	}
	else {
		die "$_? Really?\n";
	}
}

print "$stack[-1]\n";
